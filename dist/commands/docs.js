"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.docsCommand = docsCommand;
const fs_1 = require("fs");
const path_1 = require("path");
async function docsCommand() {
    console.log('üìñ FORGE Documentation Generator\n');
    try {
        if (!(0, fs_1.existsSync)('Anchor.toml')) {
            console.error('‚ùå Not in an Anchor project directory');
            process.exit(1);
        }
        const idlPath = (0, path_1.join)('target', 'idl', `${getProgramName()}.json`);
        if (!(0, fs_1.existsSync)(idlPath)) {
            console.error('‚ùå IDL not found. Run "anchor build" first.');
            process.exit(1);
        }
        const idl = JSON.parse((0, fs_1.readFileSync)(idlPath, 'utf8'));
        const docsDir = (0, path_1.join)('docs');
        (0, fs_1.mkdirSync)(docsDir, { recursive: true });
        let docs = `# ${idl.name} - API Documentation\n\n`;
        docs += `Generated by FORGE\n\n`;
        docs += `## Program ID\n\`\`\`\n${getProgramId()}\n\`\`\`\n\n`;
        if (idl.instructions) {
            docs += `## Instructions\n\n`;
            for (const instruction of idl.instructions) {
                docs += `### ${instruction.name}\n\n`;
                if (instruction.accounts) {
                    docs += `**Accounts:**\n\n`;
                    for (const account of instruction.accounts) {
                        docs += `- \`${account.name}\`: ${account.isMut ? 'Mutable' : 'Read-only'} ${account.isSigner ? 'Signer' : ''}\n`;
                    }
                    docs += '\n';
                }
                if (instruction.args) {
                    docs += `**Arguments:**\n\n`;
                    for (const arg of instruction.args) {
                        docs += `- \`${arg.name}\`: ${arg.type}\n`;
                    }
                    docs += '\n';
                }
            }
        }
        if (idl.accounts) {
            docs += `## Accounts\n\n`;
            for (const account of idl.accounts) {
                docs += `### ${account.name}\n\n`;
                if (account.type?.fields) {
                    for (const field of account.type.fields) {
                        docs += `- \`${field.name}\`: ${field.type}\n`;
                    }
                }
                docs += '\n';
            }
        }
        (0, fs_1.writeFileSync)((0, path_1.join)(docsDir, 'API.md'), docs);
        console.log('‚úÖ Documentation generated: docs/API.md');
    }
    catch (error) {
        console.error('‚ùå Documentation generation failed');
        console.error(`Error: ${error.message}`);
        process.exit(1);
    }
}
function getProgramName() {
    try {
        const anchorToml = (0, fs_1.readFileSync)('Anchor.toml', 'utf8');
        const match = anchorToml.match(/\[programs\.localnet\]\s*([^=]+)\s*=\s*"([^"]+)"/);
        return match ? match[1] : 'my-program';
    }
    catch {
        return 'my-program';
    }
}
function getProgramId() {
    try {
        const anchorToml = (0, fs_1.readFileSync)('Anchor.toml', 'utf8');
        const match = anchorToml.match(/\[programs\.localnet\]\s*([^=]+)\s*=\s*"([^"]+)"/);
        return match ? match[2] : 'Unknown';
    }
    catch {
        return 'Unknown';
    }
}
//# sourceMappingURL=docs.js.map